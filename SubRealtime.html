<!DOCTYPE html>
<html lang="vi">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>SubRealtime - Nh·∫≠n d·∫°ng v√† d·ªãch gi·ªçng n√≥i th·ªùi gian th·ª±c</title>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
	<style>
		:root {
			--primary-color: #4a148c;
			--secondary-color: #7b1fa2;
			--text-color: #f5f5f5;
			--background-dark: #121212;
			--background-light: #1e1e1e;
			--accent-color: #aa00ff;
			--danger-color: #d32f2f;
			--success-color: #388e3c;
			--warning-color: #f57f17;
			--info-color: #0288d1;
		}

        :root {
            --primary-color: #4a148c;
            --secondary-color: #7b1fa2;
            --text-color: #f5f5f5;
            --background-dark: #121212;
            --background-light: #1e1e1e;
            --accent-color: #aa00ff;
            --danger-color: #d32f2f;
            --success-color: #388e3c;
            --warning-color: #f57f17;
            --info-color: #0288d1;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-dark);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            padding: 10px 0;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--accent-color);
        }

        h1 {
            margin: 0;
            color: var(--accent-color);
        }

        .status-bar {
            background-color: var(--background-light);
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .status-message {
            flex-grow: 1;
        }

        .status-bar.recording {
            background-color: rgba(170, 0, 255, 0.3);
            border-left: 4px solid var(--accent-color);
        }

        .status-bar.error {
            background-color: rgba(211, 47, 47, 0.3);
            border-left: 4px solid var(--danger-color);
        }

        .status-bar.success {
            background-color: rgba(56, 142, 60, 0.3);
            border-left: 4px solid var(--success-color);
        }

        .status-bar.warning {
            background-color: rgba(245, 127, 23, 0.3);
            border-left: 4px solid var(--warning-color);
        }

        .status-bar.info {
            background-color: rgba(2, 136, 209, 0.3);
            border-left: 4px solid var(--info-color);
        }

        .status-bar.processing {
            background-color: rgba(3, 169, 244, 0.3);
            border-left: 4px solid #03a9f4;
        }

        .language-tabs {
            display: flex;
            margin-bottom: 15px;
            border-radius: 5px;
            overflow: hidden;
            background-color: var(--background-light);
        }

        .language-tab {
            flex-grow: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            border: none;
            background-color: var(--background-light);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

            .language-tab:hover {
                background-color: rgba(170, 0, 255, 0.3);
            }

            .language-tab.active {
                background-color: var(--accent-color);
                color: white;
            }

        .floating-action-bar {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            z-index: 1000;
            padding: 0 10px;
            pointer-events: none;
        }

        .action-buttons-scroll {
            display: flex;
            flex-wrap: nowrap;
            gap: 8px;
            padding: 10px;
            background-color: var(--background-light);
            border-radius: 50px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            overflow-x: auto;
            max-width: 100%;
            pointer-events: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
            white-space: nowrap;
        }

            .action-buttons-scroll::-webkit-scrollbar {
                display: none;
            }

            .action-buttons-scroll .btn {
                flex: 0 0 auto;
                padding: 8px;
                min-width: 40px;
                width: 40px;
                height: 40px;
                font-size: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
                border: none;
                cursor: pointer;
                color: white;
                transition: all 0.3s ease;
                position: relative;
            }

                .action-buttons-scroll .btn:hover {
                    background-color: var(--secondary-color);
                    transform: translateY(-2px);
                }

                .action-buttons-scroll .btn:active::after {
                    content: attr(title);
                    position: absolute;
                    bottom: 100%;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: var(--background-light);
                    color: var(--text-color);
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 12px;
                    white-space: nowrap;
                    z-index: 1000;
                    pointer-events: none;
                }

        .btn-mic {
            background-color: var(--accent-color);
        }

            .btn-mic.active {
                background-color: var(--danger-color);
                animation: pulse 1.5s infinite;
            }

        .btn-bilingual {
            background-color: var(--info-color);
        }

            .btn-bilingual.active {
                background-color: var(--danger-color);
                animation: pulse 1.5s infinite;
            }

        .btn-correct {
            background-color: var(--success-color);
        }

        .btn-translate {
            background-color: var(--info-color);
        }

        .btn-vocab {
            background-color: var(--warning-color);
        }

        .btn-clear {
            background-color: var(--danger-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(211, 47, 47, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(211, 47, 47, 0);
            }
        }

        .content-box {
            background-color: var(--background-light);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

            .content-box h3 {
                margin-top: 0;
                color: var(--accent-color);
                border-bottom: 1px solid rgba(170, 0, 255, 0.3);
                padding-bottom: 5px;
            }

        .result-box {
            min-height: 80px;
            white-space: pre-wrap;
        }

        .corrected-box, .translation-box, .vocab-box {
            border-left: 4px solid var(--accent-color);
        }

        .hidden {
            display: none;
        }

        textarea {
            width: 100%;
            padding: 10px;
            background-color: var(--background-dark);
            border: 1px solid #333;
            border-radius: 5px;
            color: var(--text-color);
            min-height: 120px;
            resize: vertical;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th, td {
            padding: 8px;
            border: 1px solid #333;
        }

        th {
            background-color: var(--background-dark);
            color: var(--accent-color);
        }

        tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.2);
        }

        .sentence-pair {
            margin-bottom: 15px;
            border-bottom: 1px dashed #444;
            padding-bottom: 10px;
        }

        .original-sentence {
            color: var(--accent-color);
        }

        .translated-sentence {
            color: #4CAF50;
        }

        .copy-spreadsheet-btn {
            background-color: var(--secondary-color);
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s ease;
        }

            .copy-spreadsheet-btn:hover {
                background-color: var(--accent-color);
            }

            .copy-spreadsheet-btn.copied {
                background-color: var(--success-color);
            }

        .vocab-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(170, 0, 255, 0.3);
            padding-bottom: 5px;
        }

            .vocab-header h3 {
                margin: 0;
                color: var(--accent-color);
            }

            .vocab-header .copy-spreadsheet-btn {
                margin-top: 0;
                padding: 6px 12px;
                font-size: 14px;
                white-space: nowrap;
            }

        .corrected-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(170, 0, 255, 0.3);
            padding-bottom: 5px;
        }

            .corrected-header h3 {
                margin: 0;
                color: var(--accent-color);
            }

        .corrected-actions {
            display: flex;
            gap: 8px;
        }

            .corrected-actions .btn {
                padding: 6px 10px;
                font-size: 14px;
                min-width: unset;
                border-radius: 5px;
            }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .floating-action-bar {
                bottom: 10px;
                padding: 0 5px;
            }

            .action-buttons-scroll {
                gap: 6px;
                padding: 8px;
            }

                .action-buttons-scroll .btn {
                    min-width: 36px;
                    width: 36px;
                    height: 36px;
                    padding: 6px;
                    font-size: 16px;
                }

                    .action-buttons-scroll .btn:active::after {
                        font-size: 10px;
                        padding: 3px 6px;
                    }

            .corrected-actions {
                gap: 4px;
            }

                .corrected-actions .btn {
                    padding: 4px 8px;
                    font-size: 12px;
                }

            .vocab-header .copy-spreadsheet-btn {
                padding: 4px 8px;
                font-size: 12px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }

            .action-buttons-scroll .btn {
                min-width: 32px;
                width: 32px;
                height: 32px;
                padding: 5px;
                font-size: 14px;
            }

            .action-buttons-scroll {
                gap: 5px;
                padding: 6px;
            }
        }

        @media (min-width: 1200px) {
            .action-buttons-scroll {
                overflow-x: visible;
                justify-content: center;
            }
        }

        .btn-editable {
            background-color: var(--warning-color);
            color: black;
        }
		.home-button {
			position: fixed;
			top: 20px;
			left: 20px;
			z-index: 101;
			background-color: #8a2be2; /* M√†u t√≠m */
			color: white;
			width: 50px;
			height: 50px;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			box-shadow: 0 2px 10px rgba(0,0,0,0.2);
			transition: all 0.3s ease;
		}

		.home-button:hover {
			background-color: #7b1fa2; /* M√†u t√≠m ƒë·∫≠m h∆°n khi hover */
			transform: scale(1.1);
		}

		.home-button i {
			font-size: 20px;
		}

	</style>
</head>
<body>
	<a href="index.html" class="home-button fade-in">
		<i class="fas fa-home"></i>
	</a>

    <div class="container">
        <header>
            <h1>SubRealtime</h1>
            <p>Nh·∫≠n d·∫°ng gi·ªçng n√≥i th·ªùi gian th·ª±c v·ªõi ch·ªânh s·ª≠a v√† d·ªãch thu·∫≠t</p>
        </header>

        <div id="statusBar" class="status-bar">
            <span id="statusMessage" class="status-message">S·∫µn s√†ng</span>
        </div>

        <div class="language-tabs">
            <button id="langVi" class="language-tab active" onclick="onLanguageTabClick('vi-VN')">üáªüá≥ Ti·∫øng Vi·ªát</button>
            <button id="langEn" class="language-tab" onclick="onLanguageTabClick('en-US')">üá∫üá∏ Ti·∫øng Anh</button>
            <button id="langJa" class="language-tab" onclick="onLanguageTabClick('ja-JP')">üáØüáµ Ti·∫øng Nh·∫≠t</button>
        </div>

        <div id="resultContainer" class="content-box">
            <h3>Nh·∫≠n d·∫°ng gi·ªçng n√≥i</h3>
            <div id="resultBox" class="result-box"></div>
        </div>

        <div id="correctedContainer" class="content-box corrected-box hidden">
            <div class="corrected-header">
                <h3>ƒê√£ ch·ªânh s·ª≠a</h3>
                <div class="corrected-actions">
                    <button id="speakButton" class="btn" onclick="onSpeakButtonClick()">üîä Ph√°t √¢m</button>
                    <button id="stopSpeakButton" class="btn btn-clear hidden" onclick="onStopSpeakButtonClick()">‚èπÔ∏è D·ª´ng</button>
                    <button id="translateCorrectedButton" class="btn btn-translate" onclick="onTranslateCorrectedClick()">üîÑ D·ªãch</button>
                </div>
            </div>
            <div id="correctedBox" class="result-box"></div>
        </div>

        <div id="translationContainer" class="content-box translation-box hidden">
            <h3>B·∫£n d·ªãch </h3>
            <div id="translationText" class="result-box"></div>
        </div>

        <div id="vocabContainer" class="content-box vocab-box hidden">
            <div class="vocab-header">
                <h3>T·ª´ v·ª±ng g·ª£i √Ω</h3>
                <button class="copy-spreadsheet-btn" onclick="copyVocabulary()">‚éò Copy t·ª´ v·ª±ng</button>
            </div>
            <div id="vocabList"></div>
        </div>

        <div id="editableContainer" class="content-box hidden">
            <h3>So·∫°n th·∫£o vƒÉn b·∫£n</h3>
            <textarea id="editableText" placeholder="N·ªôi dung c√≥ th·ªÉ ch·ªânh s·ª≠a ·ªü ƒë√¢y..."></textarea>
        </div>
    </div>

    <script>
        const GEMINI_API_KEY = "AIzaSyDaROReiR48rjfavf8Lk6XvphC6QxKPZo4";
        // Initialize currentLang with default language

        // --- C√ÅC BI·∫æN TR·∫†NG TH√ÅI CH√çNH ---
        let isRecording = false;            // ƒêang ghi √¢m hay kh√¥ng
        let finalTranscript = '';           // K·∫øt qu·∫£ nh·∫≠n d·∫°ng cu·ªëi c√πng
        let interimTranscript = '';         // K·∫øt qu·∫£ t·∫°m th·ªùi trong qu√° tr√¨nh nh·∫≠n d·∫°ng
        let correctedText = '';             // VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c ch·ªânh s·ª≠a ng·ªØ ph√°p
        let translatedText = '';            // VƒÉn b·∫£n ƒë√£ ƒë∆∞·ª£c d·ªãch
        let currentLang = 'vi-VN';          // Ng√¥n ng·ªØ hi·ªán t·∫°i
        let recognitionStoppedManually = false; // Ki·ªÉm so√°t d·ª´ng th·ªß c√¥ng
        let recognition = null;             // ƒê·ªëi t∆∞·ª£ng nh·∫≠n d·∫°ng gi·ªçng n√≥i
        let isProcessing = false; // Tr√°nh x·ª≠ l√Ω ch·ªìng ch√©o
        let sentenceBuffer = ""; // L∆∞u t·∫°m c√¢u ƒëang nh·∫≠n di·ªán
        let bilingualMode = false;
        let translationWorker;
        let currentUtterance = null;

        // --- QU·∫¢N L√ù DOM ELEMENTS ---
        const elements = {
            statusBar: document.getElementById('statusBar'),
            statusMessage: document.getElementById('statusMessage'),
            resultBox: document.getElementById('resultBox'),
            correctedBox: document.getElementById('correctedBox'),
            correctedContainer: document.getElementById('correctedContainer'),
            translationText: document.getElementById('translationText'),
            translationContainer: document.getElementById('translationContainer'),
            vocabList: document.getElementById('vocabList'),
            vocabContainer: document.getElementById('vocabContainer'),
            editableText: document.getElementById('editableText'),
            translationBox: document.getElementById('translationContainer'),
            vocabBox: document.getElementById('vocabContainer'),
            langTabs: {
                vi: document.getElementById('langVi'),
                en: document.getElementById('langEn'),
                ja: document.getElementById('langJa')
            }
        };

        function initTranslationWorker() {
            if (window.Worker) {
                translationWorker = new Worker('translation-worker.js');
                translationWorker.onmessage = function (e) {
                    elements.translationText.textContent = e.data;
                    elements.translationContainer.classList.remove('hidden');
                };
            } else {
                console.warn('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Web Worker');
            }
        }

        // --- KH·ªûI T·∫†O NH·∫¨N D·∫†NG GI·ªåNG N√ìI ---
        function initSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                showStatus('error', 'Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ nh·∫≠n di·ªán gi·ªçng n√≥i');
                return false;
            }

            try {
                // T·∫°o ƒë·ªëi t∆∞·ª£ng nh·∫≠n d·∫°ng
                recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();

                // C·∫•u h√¨nh
                recognition.lang = currentLang;
                recognition.interimResults = true;  // Cho ph√©p k·∫øt qu·∫£ t·∫°m th·ªùi
                recognition.continuous = true;      // Nh·∫≠n d·∫°ng li√™n t·ª•c
                recognition.maxAlternatives = 3;    // S·ªë l∆∞·ª£ng ph∆∞∆°ng √°n thay th·∫ø

                // X·ª≠ l√Ω c√°c s·ª± ki·ªán
                recognition.onresult = handleRecognitionResult;
                recognition.onstart = handleRecognitionStart;
                recognition.onend = handleRecognitionEnd;
                recognition.onerror = handleRecognitionError;

                return true;
            } catch (error) {
                console.error("L·ªói kh·ªüi t·∫°o nh·∫≠n d·∫°ng gi·ªçng n√≥i:", error);
                showStatus('error', `L·ªói kh·ªüi t·∫°o: ${error.message}`);
                return false;
            }
        }

        // --- X·ª¨ L√ù K·∫æT QU·∫¢ NH·∫¨N D·∫†NG ---
        function handleRecognitionResult(event) {
            if (isProcessing) return; // B·ªè qua n·∫øu ƒëang x·ª≠ l√Ω c√¢u tr∆∞·ªõc

            let interimResult = '';
            let finalResult = '';

            // L·ªçc k·∫øt qu·∫£
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript.trim();
                if (event.results[i].isFinal) {
                    finalResult += transcript + ' ';
                } else {
                    interimResult += transcript + ' ';
                }
            }

            // Ch·ªâ x·ª≠ l√Ω khi c√≥ c√¢u ho√†n ch·ªânh v√† ƒë·ªô d√†i h·ª£p l√Ω
            if (finalResult) {
                const sentence = finalResult.trim();
                if (sentence.split(' ').length < 25) { // Ch·ªâ x·ª≠ l√Ω c√¢u ng·∫Øn
                    sentenceBuffer = sentence;
                    processSentence(sentenceBuffer); // X·ª≠ l√Ω pipeline
                }
            }

            // Hi·ªÉn th·ªã k·∫øt qu·∫£ t·∫°m th·ªùi (n·∫øu c√≥)
            if (interimResult) {
                elements.resultBox.textContent = (sentenceBuffer ? sentenceBuffer + ' ' : '') + interimResult;
            }
        }

        // H√†m x·ª≠ l√Ω pipeline cho m·ªói c√¢u
        async function processSentence(sentence) {
            try {
                isProcessing = true;
                showStatus('processing', 'ƒêang x·ª≠ l√Ω c√¢u...');

                // 1. Hi·ªÉn th·ªã c√¢u g·ªëc trong resultBox
                elements.resultBox.textContent = sentence;

                // 2. Th√™m v√†o editableText
                const currentContent = elements.editableText.value.trim();
                elements.editableText.value = currentContent ? currentContent + '\n' + sentence : sentence;

                // 3. ƒê·ªìng b·ªô UI
                await new Promise(resolve => requestAnimationFrame(resolve));
                elements.editableText.scrollTop = elements.editableText.scrollHeight;

                // 4. D·ªãch t·ª± ƒë·ªông n·∫øu b·∫≠t ch·∫ø ƒë·ªô song ng·ªØ
                if (bilingualMode) {
                    const translated = await translateText(sentence, currentLang, getTargetLanguage(currentLang));
                    elements.translationText.textContent = translated;
                    elements.translationContainer.classList.remove('hidden');
                }

            } catch (error) {
                console.error("Pipeline l·ªói:", error);
            } finally {
                isProcessing = false;
                sentenceBuffer = "";
            }
        }

        // --- B·∫ÆT ƒê·∫¶U NH·∫¨N D·∫†NG ---
        function startRecognition() {
            try {
                if (!recognition) {
                    if (!initSpeechRecognition()) return;
                }

                // C·∫•u h√¨nh ng√¥n ng·ªØ hi·ªán t·∫°i
                recognition.lang = currentLang;

                // B·∫Øt ƒë·∫ßu ghi √¢m
                recognition.start();
                isRecording = true;
                recognitionStoppedManually = false;

                // C·∫≠p nh·∫≠t UI
                updateMicButtonState(true);
                showStatus('recording', 'ƒêang nghe... ');

            } catch (error) {
                console.error("L·ªói khi b·∫Øt ƒë·∫ßu nh·∫≠n d·∫°ng:", error);
                showStatus('error', `Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu ghi √¢m: ${error.message}`);
            }
        }

        // --- D·ª™NG NH·∫¨N D·∫†NG ---
        function stopRecognition() {
            try {
                recognitionStoppedManually = true;
                if (recognition) {
                    recognition.stop();
                }

                // C·∫≠p nh·∫≠t tr·∫°ng th√°i
                isRecording = false;

                // C·∫≠p nh·∫≠t UI
                updateMicButtonState(false);
                showStatus('ready', 'ƒê√£ d·ª´ng ghi √¢m');

                // Hi·ªÉn th·ªã k·∫øt qu·∫£ cu·ªëi c√πng (bao g·ªìm c·∫£ t·∫°m th·ªùi n·∫øu c√≥)
                if (interimTranscript.trim()) {
                    finalTranscript += interimTranscript.trim() + ' ';
                    elements.resultBox.textContent = finalTranscript.trim();
                    interimTranscript = '';
                }
            } catch (error) {
                console.error("L·ªói khi d·ª´ng nh·∫≠n d·∫°ng:", error);
                showStatus('error', `L·ªói khi d·ª´ng ghi √¢m: ${error.message}`);
            }
        }

        // --- X·ª¨ L√ù KHI NH·∫¨N D·∫†NG K·∫æT TH√öC ---
        function handleRecognitionEnd() {
            isRecording = false;
            updateMicButtonState(false);

            // X·ª≠ l√Ω k·∫øt qu·∫£ t·∫°m th·ªùi c√≤n l·∫°i n·∫øu c√≥
            if (interimTranscript.trim()) {
                finalTranscript += interimTranscript.trim() + ' ';
                elements.resultBox.textContent = finalTranscript.trim();
                interimTranscript = '';
            }

            // Kh√¥ng t·ª± ƒë·ªông l∆∞u v√†o editable box
            // Kh√¥ng t·ª± ƒë·ªông ch·ªânh s·ª≠a ho·∫∑c d·ªãch

            // T·ª± ƒë·ªông kh·ªüi ƒë·ªông l·∫°i n·∫øu kh√¥ng d·ª´ng th·ªß c√¥ng
            if (!recognitionStoppedManually) {
                try {
                    recognition.start();
                    isRecording = true;
                    updateMicButtonState(true);
                    showStatus('recording', 'ƒêang nghe...');
                } catch (e) {
                    console.error("L·ªói khi kh·ªüi ƒë·ªông l·∫°i:", e);
                    showStatus('error', 'Kh√¥ng th·ªÉ ti·∫øp t·ª•c ghi √¢m');
                }
            } else {
                recognitionStoppedManually = false; // ƒê·∫∑t l·∫°i c·ªù
            }
        }

        // --- CH·ªàNH S·ª¨A VƒÇN B·∫¢N B·∫∞NG GEMINI API ---
        async function correctText(text, sourceLang) {
            if (!text || text.trim() === '') {
                return '';
            }

            showStatus('processing', 'ƒêang ch·ªânh s·ª≠a c√¢u...');

            try {
                const languageMap = {
                    'vi-VN': 'Vietnamese',
                    'en-US': 'English',
                    'ja-JP': 'Japanese'
                };

                const language = languageMap[sourceLang] || 'English';

                const prompt = `Please correct and improve this ${language} text for natural
                          grammar, flow and accuracy. Only return the corrected text,
                          no explanations:\n\n"${text}"`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.2,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 1024,
                        }
                    })
                });

                const data = await response.json();

                if (data.candidates && data.candidates[0]?.content?.parts && data.candidates[0].content.parts[0]?.text) {
                    correctedText = data.candidates[0].content.parts[0].text.trim();
                    showStatus('success', 'ƒê√£ ch·ªânh s·ª≠a c√¢u');
                    return correctedText;
                } else {
                    throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi t·ª´ API');
                }
            } catch (error) {
                console.error('L·ªói khi ch·ªânh s·ª≠a c√¢u:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ ch·ªânh s·ª≠a c√¢u');
                return text; // Tr·∫£ v·ªÅ vƒÉn b·∫£n g·ªëc n·∫øu l·ªói
            }
        }

        // --- D·ªäCH VƒÇN B·∫¢N B·∫∞NG GEMINI API ---
        async function translateText(text, sourceLang, targetLang) {
            if (!text.trim()) return '';

            // S·ª≠ d·ª•ng Worker n·∫øu c√≥ (cho b·∫£n d·ªãch n·ªÅn)
            if (window.Worker && translationWorker) {
                showStatus('processing', 'ƒêang d·ªãch (n·ªÅn)...');
                translationWorker.postMessage({
                    sentence: text,
                    sourceLang: sourceLang,
                    targetLang: targetLang,
                    apiKey: GEMINI_API_KEY
                });
                return ''; // Worker s·∫Ω x·ª≠ l√Ω async
            }

            // Fallback khi kh√¥ng c√≥ Worker
            return await translateWithAPI(text, sourceLang, targetLang);
        }

        // H√†m ri√™ng cho API call (d√πng c·∫£ b·ªüi Worker v√† main thread)
        async function translateWithAPI(text, sourceLang, targetLang) {
            showStatus('processing', 'ƒêang d·ªãch c√¢u...');

            try {
                const languageMap = {
                    'vi-VN': 'Vietnamese',
                    'en-US': 'English',
                    'ja-JP': 'Japanese'
                };

                const sourceLanguage = languageMap[sourceLang] || 'Vietnamese';
                const targetLanguage = languageMap[targetLang] || 'Vietnamese';

                const prompt = `
Translate the following text from ${sourceLanguage} to ${targetLanguage} accurately.
Return only the translated text, with no explanations or additional content.
Ensure the output is strictly in ${targetLanguage} and not in any other language (e.g., Chinese).

Text to translate:
"${text}"
`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.2,
                            maxOutputTokens: 1024,
                        }
                    })
                });

                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                const translated = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim() || '';

                if (!translated) throw new Error('B·∫£n d·ªãch tr·ªëng');

                // Basic check for Chinese characters (simplified/traditional)
                const chineseCharRegex = /[\u4E00-\u9FFF]/;
                if (targetLang === 'vi-VN' && chineseCharRegex.test(translated)) {
                    console.warn('Detected Chinese characters in translation:', translated);
                    throw new Error('API tr·∫£ v·ªÅ ti·∫øng Trung thay v√¨ ti·∫øng Vi·ªát');
                }

                showStatus('success', 'ƒê√£ d·ªãch xong');
                return translated;
            } catch (error) {
                console.error('L·ªói d·ªãch:', error);
                showStatus('error', 'L·ªói d·ªãch: ' + (error.message || ''));
                return '';
            }
        }

        // --- G·ª¢I √ù T·ª™ V·ª∞NG ---
        async function suggestVocabulary(text, sourceLang) {
            if (!text || text.trim() === '') {
                return '<i>Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ g·ª£i √Ω t·ª´ v·ª±ng</i>';
            }

            showStatus('processing', 'ƒêang l·∫•y t·ª´ v·ª±ng...');

            try {
                const languageMap = {
                    'vi-VN': 'Vietnamese',
                    'en-US': 'English',
                    'ja-JP': 'Japanese'
                };

                const language = languageMap[sourceLang] || 'English';

                let prompt;
                if (sourceLang === 'ja-JP') {
                    prompt = `
Analyze the following Japanese text and extract a list of important vocabulary words in the format:
Kanji = Hiragana = Vietnamese Meaning

Requirements:
- Each line must follow the format: Kanji = Hiragana = Vietnamese Meaning.
- For words without Kanji (e.g., pure Hiragana), use the same text for both Kanji and Hiragana fields.
- Select only significant or challenging vocabulary relevant to the text's context.
- Provide concise Vietnamese meanings that match the word's usage in the text.
- Do not include explanations or additional text beyond the vocabulary list.
- Return an empty list if no significant vocabulary is found.

Text to analyze:
"${text}"
`;
                } else {
                    // Prompt for other languages (e.g., vi-VN, en-US)
                    prompt = `
Analyze the following ${language} text and extract a list of important vocabulary words in the format:
Word = Vietnamese Meaning

Requirements:
- Each line must follow the format: Word = Vietnamese Meaning.
- Select only significant or challenging vocabulary relevant to the text's context.
- Provide concise Vietnamese meanings that match the word's usage in the text.
- Do not include explanations or additional text beyond the vocabulary list.
- Return an empty list if no significant vocabulary is found.

Text to analyze:
"${text}"
`;
                }

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: {
                            temperature: 0.3,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 512,
                        }
                    })
                });

                const data = await response.json();

                if (!data.candidates || !data.candidates[0]?.content?.parts[0]?.text) {
                    throw new Error('Kh√¥ng nh·∫≠n ƒë∆∞·ª£c t·ª´ v·ª±ng t·ª´ API');
                }

                const rawText = data.candidates[0].content.parts[0].text.trim();

                if (rawText.toLowerCase().includes('no vocabulary') || rawText === '') {
                    return '<i>Kh√¥ng c√≥ t·ª´ v·ª±ng n√†o ƒë∆∞·ª£c ph√°t hi·ªán.</i>';
                }

                // Process results for Japanese (3 columns: Kanji, Hiragana, Meaning)
                if (sourceLang === 'ja-JP') {
                    const rows = rawText.split('\n')
                        .filter(line => line.trim() && line.includes('='))
                        .map(line => {
                            const parts = line.split('=').map(s => s.trim());
                            if (parts.length >= 3) {
                                return `<tr>
                            <td>${parts[0]}</td>
                            <td>${parts[1]}</td>
                            <td>${parts.slice(2).join(' - ')}</td>
                        </tr>`;
                            }
                            return '';
                        })
                        .filter(row => row !== '');

                    return `
                <table border="1" cellpadding="5" style="border-collapse: collapse; width: 100%;">
                    <tr style="background-color: #222;">
                        <th>Kanji</th>
                        <th>Hiragana</th>
                        <th>Nghƒ©a</th>
                    </tr>
                    ${rows.join('\n')}
                </table>
            `;
                }
                // Process for other languages (2 columns: Word, Meaning)
                else {
                    const rows = rawText.split('\n')
                        .filter(line => line.trim() && line.includes('='))
                        .map(line => {
                            const parts = line.split('=').map(s => s.trim());
                            return `<tr>
                        <td>${parts[0]}</td>
                        <td>${parts.slice(1).join(' - ')}</td>
                    </tr>`;
                        });

                    return `
                <table border="1" cellpadding="5" style="border-collapse: collapse; width: 100%;">
                    <tr style="background-color: #222;">
                        <th>T·ª´ v·ª±ng</th>
                        <th>Nghƒ©a</th>
                    </tr>
                    ${rows.join('\n')}
                </table>
            `;
                }

            } catch (error) {
                console.error('L·ªói khi l·∫•y t·ª´ v·ª±ng:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ l·∫•y t·ª´ v·ª±ng');
                return '<i>Kh√¥ng th·ªÉ l·∫•y t·ª´ v·ª±ng</i>';
            }
        }

        // --- C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI N√öT MIC ---
        function toggleRecognition() {
            if (isRecording) {
                stopRecognition();
            } else {
                startRecognition();
            }
        }

        // --- TOGGLE HI·ªÇN TH·ªä C√ÇU CH·ªàNH S·ª¨A ---
        async function toggleCorrectedText() {
            const container = elements.correctedContainer;
            if (!container.classList.contains('hidden')) {
                container.classList.add('hidden');
                return;
            }

            try {
                const rawText = elements.editableText.value.trim();
                if (!rawText) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ch·ªânh s·ª≠a');
                    return;
                }

                const corrected = await correctText(rawText, currentLang);
                elements.correctedBox.textContent = corrected;
                container.classList.remove('hidden');
                elements.editableText.value = corrected;
                showStatus('success', 'ƒê√£ hi·ªÉn th·ªã c√¢u ch·ªânh s·ª≠a');
            } catch (error) {
                console.error('L·ªói toggle ch·ªânh s·ª≠a:', error);
                showStatus('error', 'L·ªói khi hi·ªÉn th·ªã c√¢u ch·ªânh s·ª≠a');
            }
        }


        // C·∫≠p nh·∫≠t h√†m toggleTranslation ƒë·ªÉ d·ªãch t·ª´ editable box
        async function toggleTranslation() {
            const container = elements.translationContainer;
            if (!container.classList.contains('hidden')) {
                container.classList.add('hidden');
                return;
            }

            try {
                const textToTranslate = elements.editableText.value.trim();
                if (!textToTranslate) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ d·ªãch');
                    return;
                }

                const targetLang = getTargetLanguage(currentLang);
                const translated = await translateText(textToTranslate, currentLang, targetLang);

                elements.translationText.textContent = translated;
                container.classList.remove('hidden');
                showStatus('success', 'ƒê√£ d·ªãch n·ªôi dung t·ª´ h·ªôp so·∫°n th·∫£o');
            } catch (error) {
                console.error('L·ªói toggle d·ªãch:', error);
                showStatus('error', 'L·ªói khi d·ªãch n·ªôi dung t·ª´ h·ªôp so·∫°n th·∫£o');
            }
        }


        // --- TOGGLE HI·ªÇN TH·ªä T·ª™ V·ª∞NG ---
        async function toggleVocabulary() {
            const container = elements.vocabContainer;
            if (!container.classList.contains('hidden')) {
                container.classList.add('hidden');
                return;
            }

            try {
                const textForVocab = elements.editableText.value.trim();
                if (!textForVocab) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ g·ª£i √Ω t·ª´ v·ª±ng');
                    return;
                }

                const vocabHTML = await suggestVocabulary(textForVocab, currentLang);
                elements.vocabList.innerHTML = vocabHTML;
                container.classList.remove('hidden');
                showStatus('success', 'ƒê√£ hi·ªÉn th·ªã g·ª£i √Ω t·ª´ v·ª±ng');
            } catch (error) {
                console.error('L·ªói toggle t·ª´ v·ª±ng:', error);
                showStatus('error', 'L·ªói khi hi·ªÉn th·ªã g·ª£i √Ω t·ª´ v·ª±ng');
            }
        }


        // --- L∆ØU VƒÄN B·∫¢N G·ªêC V√ÄO EDITABLE ---
        function saveToEditable() {
            try {
                // Th√™m n·ªôi dung hi·ªán t·∫°i v√†o editable
                const currentContent = elements.editableText.value.trim();
                const newContent = elements.resultBox.textContent.trim();

                if (!newContent) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ l∆∞u');
                    return;
                }

                // Th√™m d·∫•u xu·ªëng d√≤ng n·∫øu ƒë√£ c√≥ n·ªôi dung
                if (currentContent) {
                    elements.editableText.value = currentContent + '\n' + newContent;
                } else {
                    elements.editableText.value = newContent;
                }

                showStatus('success', 'ƒê√£ l∆∞u vƒÉn b·∫£n');
            } catch (error) {
                console.error('L·ªói khi l∆∞u vƒÉn b·∫£n:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ l∆∞u vƒÉn b·∫£n');
            }
        }

        // --- X√ìA T·∫§T C·∫¢ ---
        function clearAll() {
            try {
                // D·ª´ng ghi √¢m n·∫øu ƒëang ch·∫°y
                if (isRecording) {
                    stopRecognition();
                }

                // X√≥a n·ªôi dung c√°c ph·∫ßn t·ª≠
                elements.editableText.value = '';
                elements.resultBox.textContent = '';
                elements.correctedBox.textContent = '';
                elements.translationText.textContent = '';
                elements.vocabList.innerHTML = '';

                // ·∫®n c√°c box kh√¥ng c·∫ßn thi·∫øt
                elements.correctedBox.classList.add('hidden');
                elements.translationBox.classList.add('hidden');
                elements.vocabBox.classList.add('hidden');

                // Reset c√°c bi·∫øn tr·∫°ng th√°i
                finalTranscript = '';
                interimTranscript = '';
                correctedText = '';
                translatedText = '';

                showStatus('info', 'ƒê√£ x√≥a t·∫•t c·∫£ n·ªôi dung');
            } catch (error) {
                console.error('L·ªói khi x√≥a:', error);
                showStatus('error', 'L·ªói khi x√≥a n·ªôi dung');
            }
        }

        // --- PH√ÅT √ÇM B·∫¢N D·ªäCH ---
        function speakTranslation() {
            try {
                // X√°c ƒë·ªãnh vƒÉn b·∫£n c·∫ßn ph√°t √¢m
                const textToSpeak = elements.translationText.textContent.trim();

                if (!textToSpeak) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë·ªÉ ph√°t √¢m');
                    return;
                }

                // X√°c ƒë·ªãnh ng√¥n ng·ªØ cho ph√°t √¢m
                const speakLanguage = getTargetLanguage(currentLang);

                // Ph√°t √¢m b·∫±ng Web Speech API
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.lang = speakLanguage;
                speechSynthesis.speak(utterance);

                showStatus('info', 'ƒêang ph√°t √¢m...');
            } catch (error) {
                console.error('L·ªói khi ph√°t √¢m:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ ph√°t √¢m');
            }
        }

        function getTargetLanguage(sourceLang) {
            // ƒê·∫£m b·∫£o lu√¥n d·ªãch sang ti·∫øng Vi·ªát n·∫øu kh√¥ng ph·∫£i ti·∫øng Vi·ªát
            if (sourceLang !== 'vi-VN') {
                return 'vi-VN';
            }
            // N·∫øu l√† ti·∫øng Vi·ªát th√¨ d·ªãch sang ti·∫øng Anh
            return 'en-US';
        }

        // --- THAY ƒê·ªîI NG√îN NG·ªÆ ---
        function changeLanguage(newLang) {
            currentLang = newLang;

            // C·∫≠p nh·∫≠t UI
            updateUILanguage(newLang);

            // C·∫≠p nh·∫≠t c·∫•u h√¨nh nh·∫≠n d·∫°ng gi·ªçng n√≥i
            if (recognition) {
                const wasRecording = isRecording;

                // D·ª´ng nh·∫≠n d·∫°ng hi·ªán t·∫°i
                if (wasRecording) {
                    stopRecognition();
                }

                // C·∫≠p nh·∫≠t ng√¥n ng·ªØ
                recognition.lang = newLang;

                // Kh·ªüi ƒë·ªông l·∫°i n·∫øu ƒëang ho·∫°t ƒë·ªông
                if (wasRecording) {
                    setTimeout(() => startRecognition(), 300);
                }
            }

            showStatus('info', `ƒê√£ chuy·ªÉn ng√¥n ng·ªØ th√†nh ${getLanguageDisplayName(newLang)}`);
        }

        // --- T√äN HI·ªÇN TH·ªä CHO NG√îN NG·ªÆ ---
        function getLanguageDisplayName(langCode) {
            const names = {
                'vi-VN': 'Ti·∫øng Vi·ªát',
                'en-US': 'Ti·∫øng Anh',
                'ja-JP': 'Ti·∫øng Nh·∫≠t'
            };
            return names[langCode] || langCode;
        }

        // --- LI√äN K·∫æT S·ª∞ KI·ªÜN V·ªöI C√ÅC N√öT ---
        // C√°c h√†m n√†y s·∫Ω ƒë∆∞·ª£c g·ªçi khi s·ª± ki·ªán click x·∫£y ra

        // N√∫t micro
        function onMicButtonClick() {
            toggleRecognition();
        }

        // N√∫t hi·ªÉn th·ªã c√¢u ch·ªânh s·ª≠a
        function onCorrectionButtonClick() {
            toggleCorrectedText();
        }

        // N√∫t hi·ªÉn th·ªã b·∫£n d·ªãch
        function onTranslateButtonClick() {
            toggleTranslation();
        }

        // N√∫t hi·ªÉn th·ªã t·ª´ v·ª±ng
        function onVocabButtonClick() {
            toggleVocabulary();
        }

        // N√∫t l∆∞u vƒÉn b·∫£n
        function onSaveButtonClick() {
            saveToEditable();
        }

        // N√∫t x√≥a t·∫•t c·∫£
        function onClearButtonClick() {
            clearAll();
        }

        // H√†m ph√°t √¢m
        function onSpeakButtonClick() {
            try {
                const textToSpeak = elements.correctedBox.textContent.trim();

                if (!textToSpeak) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë√£ ch·ªânh s·ª≠a ƒë·ªÉ ph√°t √¢m');
                    return;
                }

                // D·ª´ng ph√°t √¢m hi·ªán t·∫°i n·∫øu c√≥
                if (currentUtterance) {
                    speechSynthesis.cancel();
                }

                // T·∫°o utterance m·ªõi
                currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
                currentUtterance.lang = currentLang;

                // Hi·ªÉn th·ªã n√∫t d·ª´ng
                document.getElementById('stopSpeakButton').classList.remove('hidden');
                document.getElementById('speakButton').classList.add('hidden');

                // S·ª± ki·ªán khi k·∫øt th√∫c ph√°t √¢m
                currentUtterance.onend = function () {
                    document.getElementById('stopSpeakButton').classList.add('hidden');
                    document.getElementById('speakButton').classList.remove('hidden');
                    currentUtterance = null;
                };

                speechSynthesis.speak(currentUtterance);
                showStatus('info', 'ƒêang ph√°t √¢m b·∫£n ƒë√£ ch·ªânh s·ª≠a...');
            } catch (error) {
                console.error('L·ªói khi ph√°t √¢m:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ ph√°t √¢m b·∫£n ƒë√£ ch·ªânh s·ª≠a');
            }
        }

        // H√†m d·ª´ng ph√°t √¢m
        function onStopSpeakButtonClick() {
            try {
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                    document.getElementById('stopSpeakButton').classList.add('hidden');
                    document.getElementById('speakButton').classList.remove('hidden');
                    currentUtterance = null;
                    showStatus('info', 'ƒê√£ d·ª´ng ph√°t √¢m');
                }
            } catch (error) {
                console.error('L·ªói khi d·ª´ng ph√°t √¢m:', error);
                showStatus('error', 'Kh√¥ng th·ªÉ d·ª´ng ph√°t √¢m');
            }
        }

        // N√∫t chuy·ªÉn tab ng√¥n ng·ªØ
        function onLanguageTabClick(langCode) {
            changeLanguage(langCode);
        }

        // --- C·∫¨P NH·∫¨T UI THEO NG√îN NG·ªÆ ---
        function updateUILanguage(langCode) {
            // X√≥a tr·∫°ng th√°i active kh·ªèi t·∫•t c·∫£ c√°c tab
            for (const key in elements.langTabs) {
                elements.langTabs[key].classList.remove('active');
            }

            // ƒê·∫∑t tr·∫°ng th√°i active cho tab hi·ªán t·∫°i
            switch (langCode) {
                case 'vi-VN':
                    elements.langTabs.vi.classList.add('active');
                    break;
                case 'en-US':
                    elements.langTabs.en.classList.add('active');
                    break;
                case 'ja-JP':
                    elements.langTabs.ja.classList.add('active');
                    break;
            }
        }

        // --- X·ª¨ L√ù L·ªñI NH·∫¨N D·∫†NG ---
        function handleRecognitionError(event) {
            console.error("L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i:", event.error);

            let errorMessage = "L·ªói nh·∫≠n d·∫°ng gi·ªçng n√≥i";
            switch (event.error) {
                case 'no-speech':
                    errorMessage = "Kh√¥ng ph√°t hi·ªán gi·ªçng n√≥i";
                    break;
                case 'audio-capture':
                    errorMessage = "Kh√¥ng th·ªÉ truy c·∫≠p microphone";
                    break;
                case 'not-allowed':
                    errorMessage = "Quy·ªÅn truy c·∫≠p microphone b·ªã t·ª´ ch·ªëi";
                    break;
                case 'network':
                    errorMessage = "L·ªói k·∫øt n·ªëi m·∫°ng";
                    break;
                case 'aborted':
                    errorMessage = "Nh·∫≠n d·∫°ng b·ªã h·ªßy";
                    break;
                case 'language-not-supported':
                    errorMessage = "Ng√¥n ng·ªØ kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£";
                    break;
            }

            showStatus('error', errorMessage);
            isRecording = false;
            updateMicButtonState(false);
        }

        // --- X·ª¨ L√ù KHI B·∫ÆT ƒê·∫¶U NH·∫¨N D·∫†NG ---
        function handleRecognitionStart() {
            showStatus('recording', 'ƒêang nghe...');
            isRecording = true;
            updateMicButtonState(true);
        }

        // --- HI·ªÇN TH·ªä TR·∫†NG TH√ÅI ---
        function showStatus(type, message) {
            // Lo·∫°i b·ªè t·∫•t c·∫£ c√°c class tr·∫°ng th√°i hi·ªán t·∫°i
            elements.statusBar.classList.remove('recording', 'error', 'success', 'warning', 'info', 'processing');

            // Th√™m class m·ªõi t∆∞∆°ng ·ª©ng v·ªõi lo·∫°i tr·∫°ng th√°i
            elements.statusBar.classList.add(type);

            // C·∫≠p nh·∫≠t n·ªôi dung
            elements.statusMessage.textContent = message;
        }


        // --- C·∫¨P NH·∫¨T TR·∫†NG TH√ÅI N√öT MIC ---
        function updateMicButtonState(isActive) {
            const micButton = document.getElementById('micButton');
            if (!micButton) return;

            if (isActive) {
                micButton.classList.add('active');
                micButton.innerHTML = 'üõë'; // Icon d·ª´ng khi ƒëang ghi √¢m
                micButton.title = 'D·ª´ng ghi √¢m';
            } else {
                micButton.classList.remove('active');
                micButton.innerHTML = 'üéôÔ∏è'; // Icon ghi √¢m khi kh√¥ng ho·∫°t ƒë·ªông
                micButton.title = 'Ghi √¢m';
            }
        }


        // --- CH·∫æ ƒê·ªò SONG NG·ªÆ ---
        function toggleBilingualMode() {
            bilingualMode = !bilingualMode;
            const bilingualButton = document.getElementById('toggleBilingual');

            if (bilingualMode) {
                bilingualButton.classList.add('active');

                // LU√îN hi·ªán b·∫£ng d·ªãch khi b·∫≠t ch·∫ø ƒë·ªô song ng·ªØ
                elements.translationContainer.classList.remove('hidden');
                showStatus('info', 'Ch·∫ø ƒë·ªô song ng·ªØ: B·∫¨T');
            } else {
                bilingualButton.classList.remove('active');

                // ·∫®n b·∫£ng d·ªãch khi t·∫Øt ch·∫ø ƒë·ªô song ng·ªØ
                elements.translationContainer.classList.add('hidden');
                showStatus('info', 'Ch·∫ø ƒë·ªô song ng·ªØ: T·∫ÆT');
            }
        }


        // H√†m d·ªãch n·ªôi dung ƒë√£ ch·ªânh s·ª≠a
        async function onTranslateCorrectedClick() {
            try {
                const textToTranslate = elements.correctedBox.textContent.trim();

                if (!textToTranslate) {
                    showStatus('warning', 'Kh√¥ng c√≥ n·ªôi dung ƒë√£ ch·ªânh s·ª≠a ƒë·ªÉ d·ªãch');
                    return;
                }

                const targetLang = getTargetLanguage(currentLang);
                const translated = await translateText(textToTranslate, currentLang, targetLang);

                // Hi·ªÉn th·ªã trong translation box
                elements.translationText.textContent = translated;
                elements.translationContainer.classList.remove('hidden');
                showStatus('success', 'ƒê√£ d·ªãch n·ªôi dung ƒë√£ ch·ªânh s·ª≠a');
            } catch (error) {
                console.error('L·ªói khi d·ªãch n·ªôi dung ƒë√£ ch·ªânh s·ª≠a:', error);
                showStatus('error', 'L·ªói khi d·ªãch n·ªôi dung ƒë√£ ch·ªânh s·ª≠a');
            }
        }

        // H√†m sao ch√©p t·ª´ v·ª±ng
        async function copyVocabulary() {
            try {
                const vocabTable = document.querySelector('#vocabList table');
                if (!vocabTable) {
                    showStatus('warning', 'Kh√¥ng c√≥ t·ª´ v·ª±ng ƒë·ªÉ sao ch√©p');
                    return;
                }

                let textToCopy = '';
                const rows = vocabTable.querySelectorAll('tr');

                rows.forEach((row, index) => {
                    if (index === 0) return; // B·ªè qua h√†ng ti√™u ƒë·ªÅ

                    const cells = row.querySelectorAll('td');
                    let rowText = '';

                    cells.forEach((cell, cellIndex) => {
                        rowText += cell.textContent.trim();
                        if (cellIndex < cells.length - 1) {
                            rowText += ' - ';
                        }
                    });

                    textToCopy += rowText + '\n';
                });

                await navigator.clipboard.writeText(textToCopy.trim());

                // S·ª≠ d·ª•ng class ƒë·ªÉ ch·ªçn n√∫t copy
                const copyBtn = document.querySelector('.copy-spreadsheet-btn');
                if (copyBtn) {
                    copyBtn.textContent = '‚úì ƒê√£ copy';
                    copyBtn.classList.add('copied');
                }

                showStatus('success', 'ƒê√£ sao ch√©p t·ª´ v·ª±ng v√†o clipboard');

                setTimeout(() => {
                    if (copyBtn) {
                        copyBtn.textContent = '‚éò Copy t·ª´ v·ª±ng';
                        copyBtn.classList.remove('copied');
                    }
                }, 2000);

            } catch (error) {
                console.error('L·ªói khi sao ch√©p t·ª´ v·ª±ng:', error);
                showStatus('error', 'Sao ch√©p th·∫•t b·∫°i: ' + error.message);
            }
        }

        function toggleEditableBox() {
            const editableContainer = document.getElementById('editableContainer'); // d√πng id m·ªõi
            if (!editableContainer) return;

            if (editableContainer.classList.contains('hidden')) {
                editableContainer.classList.remove('hidden');
                showStatus('info', 'ƒê√£ m·ªü so·∫°n th·∫£o vƒÉn b·∫£n');
            } else {
                editableContainer.classList.add('hidden');
                showStatus('info', 'ƒê√£ ·∫©n so·∫°n th·∫£o vƒÉn b·∫£n');
            }
        }
    </script>

    <!-- Th√™m v√†o cu·ªëi th·∫ª body, tr∆∞·ªõc khi ƒë√≥ng </body> -->
    <div class="floating-action-bar">
        <div class="action-buttons-scroll">
            <button id="micButton" class="btn btn-mic" title="Ghi √¢m" onclick="onMicButtonClick()">üéôÔ∏è</button>
            <button id="toggleBilingual" class="btn btn-bilingual" title="Ch·∫ø ƒë·ªô song ng·ªØ" onclick="toggleBilingualMode()">üåê</button>
            <button id="editableButton" class="btn btn-editable" title="·∫®n/Hi·ªán So·∫°n th·∫£o" onclick="toggleEditableBox()">üìù</button>
            <button id="correctionButton" class="btn btn-correct" title="Ch·ªânh s·ª≠a" onclick="onCorrectionButtonClick()">‚úèÔ∏è</button>
            <button id="translateButton" class="btn btn-translate" title="D·ªãch" onclick="onTranslateButtonClick()">üîÑ</button>
            <button id="vocabButton" class="btn btn-vocab" title="T·ª´ v·ª±ng" onclick="onVocabButtonClick()">üìö</button>
            <button id="saveButton" class="btn" title="L∆∞u" onclick="onSaveButtonClick()">üíæ</button>
            <button id="clearButton" class="btn btn-clear" title="X√≥a t·∫•t c·∫£" onclick="onClearButtonClick()">üóëÔ∏è</button>
        </div>
    </div>
</body>
</html>
